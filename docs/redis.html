<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Redis · Monix Connect</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Introduction"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Redis · Monix Connect"/><meta property="og:type" content="website"/><meta property="og:url" content="https://connect.monix.io/"/><meta property="og:description" content="## Introduction"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://connect.monix.io/img/monix-logo.png"/><link rel="shortcut icon" href="/img/monix-logo.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/monix-logo.svg" alt="Monix Connect"/><h2 class="headerTitleWithLogo">Monix Connect</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/api/monix/connect/index.html" target="_self">API Docs</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Documentation</a></li><li class=""><a href="https://github.com/monix/monix-connect" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Documentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/parquet">Apache Parquet</a></li><li class="navListItem"><a class="navItem" href="/docs/dynamodb">AWS DynamoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/s3">AWS S3</a></li><li class="navListItem"><a class="navItem" href="/docs/sqs">AWS SQS</a></li><li class="navListItem"><a class="navItem" href="/docs/elasticsearch">Elasticsearch</a></li><li class="navListItem"><a class="navItem" href="/docs/gcs">Google Cloud Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/hdfs">HDFS</a></li><li class="navListItem"><a class="navItem" href="/docs/mongodb">MongoDB</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/redis">Redis</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Redis</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p><em>Redis</em> is an open source, in-memory data structure store, used as a database, cache and message broker.
providing high availability, scalability and a outstanding performance. sorted sets, and a set of <a href="https://redis.io/commands">commands</a>
that can run atomically on these, like appending to a string; incrementing the value in a hash; pushing an element
It supports data structures such as string, hashes, lists,
to inter-operate with, and most of them are also available from the java api.</p>
<p>This connector has been built on top of <a href="https://lettuce.io/">lettuce</a>, the most popular java library for operating with
a <em>non blocking</em> Redis client.</p>
<h2><a class="anchor" aria-hidden="true" id="dependency"></a><a href="#dependency" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency</h2>
<p>Add the following dependency:</p>
<pre><code class="hljs css language-scala">libraryDependencies += <span class="hljs-string">"io.monix"</span> %% <span class="hljs-string">"monix-redis"</span> % <span class="hljs-string">"0.6.0"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="redis-connection"></a><a href="#redis-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis Connection</h2>
<p>The first step is to create a <code>RedisConnection</code> a simple, scalable and pure interface that allows to
communicate to a Redis <em>Standalone</em> or <em>Cluster</em> servers.</p>
<p><strong>Remember</strong> that the created connection is an expensive resource, as it is made with the
underlying <em>lettuce</em> which also uses netty and holds a set of <code>io.netty.channel.EventLoopGroup</code>
that use multiple threads. So, reuse the connection as much as possible!</p>
<h3><a class="anchor" aria-hidden="true" id="standalone"></a><a href="#standalone" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standalone</h3>
<p>In order to create a standalone connection, we will use the companion object's signature <code>RedisConnection.standalone</code>,
which returns a connection instance.</p>
<p>In order to create the connection, first we would just need a single <code>monix.connect.redis.client.RedisUri</code> relative to
the redis standalone server:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}

<span class="hljs-comment">// RedisUri has an overloaded `apply` which also allows host and port to be passed separately</span>
<span class="hljs-comment">// like RedisUri("localhost", 6379) </span>
<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-comment">// then we create the connection</span>
<span class="hljs-keyword">val</span> redisConn: <span class="hljs-type">RedisConnection</span> = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="cluster"></a><a href="#cluster" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cluster</h3>
<p>Creating a <strong>cluster</strong> connection is seamlessly to the standalone one, they both end up encoded the same parent
class <code>RedisConnection</code>, but for the fact that its creation requires multiple <code>RedisUri</code>s that represent the set of redis
servers in the cluster.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}

<span class="hljs-keyword">val</span> redisNode1 = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"my.redis.node.1"</span>, <span class="hljs-number">7000</span>)
<span class="hljs-keyword">val</span> redisNode2 = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"my.redis.node.2"</span>, <span class="hljs-number">7001</span>)
<span class="hljs-keyword">val</span> redisNode3 = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"my.redis.node.3"</span>, <span class="hljs-number">7002</span>)

<span class="hljs-keyword">val</span> redisClusterConn: <span class="hljs-type">RedisConnection</span> = <span class="hljs-type">RedisConnection</span>.cluster(<span class="hljs-type">List</span>(redisNode1, redisNode2, redisNode3))
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="rediscmd"></a><a href="#rediscmd" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RedisCmd</h2>
<p>Once we got a <code>RedisConnection</code>, we can start using the <code>RedisCmd</code>, a case class that contains all the redis commands for
<em>server</em>, <em>key</em>, <em>list</em>, <em>set</em>, <em>sorted set</em> and <em>hash</em>.<br>
The <code>RedisCmd</code> is actually accessible through using a <code>cats.effect.Resource</code> with <code>monix.eval.Task</code>,
it actually abstracts the logic of acquiring and releasing the connection with its associated resources.</p>
<p>In the following example we will create a connection that by default encodes <em>Keys</em>
and <em>Values</em> as <code>Strings</code>, persisting them into <code>UTF</code> format in <em>Redis</em>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">Resource</span>
<span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> monix.eval.<span class="hljs-type">Task</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-keyword">val</span> redisConn: <span class="hljs-type">Resource</span>[<span class="hljs-type">Task</span>, <span class="hljs-type">RedisCmd</span>[<span class="hljs-type">String</span>, <span class="hljs-type">String</span>]] = <span class="hljs-type">RedisConnection</span>.standalone(redisUri).connectUtf

<span class="hljs-keyword">val</span> k1: <span class="hljs-type">String</span> = <span class="hljs-string">"key1"</span>
<span class="hljs-keyword">val</span> value: <span class="hljs-type">String</span> = <span class="hljs-string">"a"</span>
<span class="hljs-keyword">val</span> k2: <span class="hljs-type">String</span> = <span class="hljs-string">"key2"</span>
<span class="hljs-keyword">val</span> values: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>)

<span class="hljs-comment">// from there on, we can start using the connection</span>
<span class="hljs-comment">// and since `RedisCmd` is a case class, we can apply </span>
<span class="hljs-comment">// pattern matching against it, which will nicely allow us</span>
<span class="hljs-comment">// to de-compose the different RedisCommands its different api.</span>
<span class="hljs-comment">// alternatively you can also do:  redisConn.use { redisCmd =&gt; redisCmd.string.get("k1") }</span>
redisConn.use { <span class="hljs-keyword">case</span> <span class="hljs-type">RedisCmd</span>(hash, keys, list, server, set, sortedSet, string) =&gt;
  <span class="hljs-keyword">for</span> {
    _ &lt;- server.flushAll
    _ &lt;- keys.touch(k1)
    _ &lt;- string.set(k1, value)
    _ &lt;- keys.rename(k1, k2)
    _ &lt;- list.lPush(k1, values: _*)
    v &lt;- string.get(k2)
    _ &lt;- v <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt; list.lPush(k1, value)
      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">Task</span>.unit
    }
    _ &lt;- keys.del(k2)
    len &lt;- list.lLen(k1)
  } <span class="hljs-keyword">yield</span> (len)
}.runToFuture
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="custom-codecs"></a><a href="#custom-codecs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Codecs</h2>
<p>In the previous sections it was shown how to create a connection to redis and to start using the <code>RedisCmd</code> with its
different redis modules. The created connection was exposed within a cats resource as
<code>RedisCmd[String, String]</code>, meaning that it expects <code>Strings</code> for both <em>Keys</em> and <em>Values</em>.
In order to decide how do we want our redis connection to encode and decode <strong>k</strong> and <strong>v</strong>,
we would need to pass a custom <code>Codec</code> both for key and value.
A <code>Codec</code> is a sealed trait conformed by <code>UTFCodec</code> and <code>ByteArrayCodec</code>, in which you can create instances of those from its
companion object with the respective signatures <code>utf</code> and <code>byteArray</code>, see below snippet:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">package</span> monix.connect.redis.client

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Codec</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">utf</span></span>[<span class="hljs-type">T</span>](encoder: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">String</span>, decoder: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">T</span>) = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byteArray</span></span>[<span class="hljs-type">T</span>](encoder: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>], decoder: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] =&gt; <span class="hljs-type">T</span>) = ???
}
</code></pre>
<p>You will find some already predefined <code>Codec</code> for <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>BigInt</code> and <code>BigDecimal</code> under the package
object <code>monix.connect.redis._</code>.</p>
<p>The next subsections are an example of <strong>creating custom codec</strong> that mixes <code>UTFCodec</code> and <code>ByteArrayCodec</code>:</p>
<h3><a class="anchor" aria-hidden="true" id="utfcodec"></a><a href="#utfcodec" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UTFCodec</h3>
<p>In this case we will create two custom <code>UTFCodec[T]</code>, one for keys as <code>Int</code>
and the other for <code>Double</code> which will represent the redis values, resulting in <code>RedisCmd[Int, Double]</code>.</p>
<p>These two will be passed as parameters when connecting to redis with <em>connectUtf</em>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">Codec</span>, <span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>, <span class="hljs-type">UtfCodec</span>}
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">CancelableFuture</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">import</span> scala.util.{<span class="hljs-type">Failure</span>, <span class="hljs-type">Try</span>}

<span class="hljs-comment">// there is already a predefined int utf codec under `monix.connect.redis._`</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> intUtfCodec: <span class="hljs-type">UtfCodec</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Codec</span>.utf(_.toString, <span class="hljs-comment">//serializes int to str</span>
  <span class="hljs-comment">//deserializes str back to int</span>
  str =&gt; <span class="hljs-type">Try</span>(str.toInt)
    .failed.flatMap { ex =&gt;
    logger.info(<span class="hljs-string">"Failed to deserialize from Redis to `Int`"</span>)
    <span class="hljs-type">Failure</span>(ex)
  }.getOrElse(<span class="hljs-number">0</span>)
)

<span class="hljs-comment">// there is already a predefined double utf codec under `monix.connect.redis._`</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> doubleUtfCodec: <span class="hljs-type">UtfCodec</span>[<span class="hljs-type">Double</span>] = <span class="hljs-type">Codec</span>.utf(_.toString, <span class="hljs-comment">//serializes double to str</span>
  <span class="hljs-comment">//deserializes str back to double</span>
  str =&gt; <span class="hljs-type">Try</span>(str.toDouble)
    .failed.flatMap { ex =&gt;
    logger.info(<span class="hljs-string">"Failed to deserialize from Redis to `Double`"</span>)
    <span class="hljs-type">Failure</span>(ex)
  }.getOrElse(<span class="hljs-number">0.0</span>)
)

<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-keyword">val</span> f: <span class="hljs-type">CancelableFuture</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>]] = 
 <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf(intUtfCodec, doubleUtfCodec) <span class="hljs-comment">//this can be passed implicitly but is explicit for didactic purposes</span>
  .use { redisCmd: <span class="hljs-type">RedisCmd</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Double</span>] =&gt;
    <span class="hljs-comment">//your business logic here</span>
    redisCmd.list.lPush(<span class="hljs-number">11</span>, <span class="hljs-number">123.134</span>) &gt;&gt; redisCmd.list.rPop(<span class="hljs-number">11</span>) <span class="hljs-comment">//Some(123.134) </span>
  }.runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="bytescodec"></a><a href="#bytescodec" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BytesCodec</h3>
<p>On the other hand, there is also a <code>BytesCodec[T]</code>, which des/serializes from/to <code>Array[Byte]</code>.
In this case we will show an example of using <code>Protobuf</code> serialization format to dealing with redis <em>keys</em> and <em>values</em>:</p>
<p>In below snippet we defined our <em>proto</em> objects, in which <code>PersonPK</code> will represent the redis key and <code>Person</code> the value.</p>
<pre><code class="hljs css language-proto">syntax = <span class="hljs-string">"proto3"</span>;

<span class="hljs-keyword">package</span> monix.connect.redis.test;

<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">PersonPk</span> </span>{
    <span class="hljs-built_in">string</span> id = <span class="hljs-number">1</span>;
}

<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">int64</span> age = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> hobbies = <span class="hljs-number">3</span>;
}
</code></pre>
<p>With the generated proto scala sources, we can proceed to creating a <code>BytesCodec[PersonPk]</code> and <code>BytesCodec[Person]</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">BytesCodec</span>, <span class="hljs-type">Codec</span>}
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> personPkCodec: <span class="hljs-type">BytesCodec</span>[<span class="hljs-type">PersonPk</span>] = 
  <span class="hljs-type">Codec</span>.byteArray(pk =&gt; <span class="hljs-type">PersonPk</span>.toByteArray(pk), bytes =&gt; <span class="hljs-type">PersonPk</span>.parseFrom(bytes))
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> personCodec: <span class="hljs-type">BytesCodec</span>[<span class="hljs-type">Person</span>] =
  <span class="hljs-type">Codec</span>.byteArray(person =&gt; <span class="hljs-type">Person</span>.toByteArray(person), bytes =&gt; <span class="hljs-type">Person</span>.parseFrom(bytes))
</code></pre>
<p>Finally, we are ready to start creating the connection using the previously defined protobuf codecs:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">Codec</span>, <span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>, <span class="hljs-type">UtfCodec</span>}
<span class="hljs-keyword">import</span> monix.connect.redis.test.protobuf.{<span class="hljs-type">Person</span>, <span class="hljs-type">PersonPk</span>}
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">CancelableFuture</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-keyword">val</span> personPk = <span class="hljs-type">PersonPk</span>(<span class="hljs-string">"personId123"</span>)
<span class="hljs-keyword">val</span> hobbies = <span class="hljs-type">List</span>(<span class="hljs-string">"Snowboarding"</span>, <span class="hljs-string">"Programming"</span>)
<span class="hljs-keyword">val</span> person = <span class="hljs-type">Person</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>, hobbies)

<span class="hljs-keyword">val</span> f: <span class="hljs-type">CancelableFuture</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Person</span>]] =
  <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
    .connectUtf(personPkCodec, personCodec)
    .use{ redisCmd: <span class="hljs-type">RedisCmd</span>[<span class="hljs-type">PersonPk</span>, <span class="hljs-type">Person</span>] =&gt;
      <span class="hljs-keyword">for</span> {
        _ &lt;-redisCmd.string.set(personPk, person)
        person &lt;- redisCmd.string.get(personPk)
      } <span class="hljs-keyword">yield</span> person
    }.runToFuture
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="commands"></a><a href="#commands" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Commands</h2>
<p>This redis connector implementation provides a wide range of commands to perform a different operations,
for the most common used modules and types:
:  (<a href="https://redis.io/commands#generic">Keys</a>, <a href="https://redis.io/commands#hash">Hashes</a>
, <a href="https://redis.io/commands#list">List</a>, <a href="https://redis.io/commands#server">Server</a>
, <a href="https://redis.io/commands#set">Sets</a>, <a href="https://redis.io/commands#sorted_set">SortedSets</a>
and <a href="https://redis.io/commands#string">Strings</a>).
See an example on how to use each of them in the following sub-sections:</p>
<h3><a class="anchor" aria-hidden="true" id="__keys__"></a><a href="#__keys__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Keys</strong></h3>
<p>The below snippet shows a simple example of using key commands.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-keyword">val</span> k: <span class="hljs-type">String</span> <span class="hljs-comment">// assuming that the key already exists</span>
<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use(cmd =&gt;
    <span class="hljs-keyword">for</span> {
      randomKey &lt;- cmd.key.randomKey() <span class="hljs-comment">//returns a random key from the db</span>
      _ &lt;- cmd.key.expire(k, <span class="hljs-number">100</span> seconds) <span class="hljs-comment">//specifies an expiration timeout for the k1</span>
      ttl &lt;- cmd.key.ttl(k) <span class="hljs-comment">//returns the time to live as `FiniteDuration`</span>
    } <span class="hljs-keyword">yield</span> (randomKey, ttl)
  )
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__hashes__"></a><a href="#__hashes__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Hashes</strong></h3>
<p>The following example uses the redis hash api <code>RedisHash</code> to insert a single element into a hash and read it back from
the hash.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>, <span class="hljs-type">RedisCmd</span>}
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-keyword">val</span> key: <span class="hljs-type">String</span> 
<span class="hljs-keyword">val</span> field: <span class="hljs-type">String</span> 
<span class="hljs-keyword">val</span> value: <span class="hljs-type">String</span> 
<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)
<span class="hljs-keyword">val</span> prefix = <span class="hljs-string">"dummy-prefix-"</span>

<span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use { cmd =&gt;
    <span class="hljs-keyword">for</span> {
      _ &lt;- cmd.hash.hSet(key, field, value)
      <span class="hljs-comment">//adds a prefix to all values in a hash </span>
      _ &lt;- cmd.hash.hGetAll(key).mapEval { <span class="hljs-keyword">case</span> (f, v) =&gt; cmd.hash.hSet(key, f, prefix + v) }.completedL
      prefixedValue &lt;- cmd.hash.hGet(key, field)
    } <span class="hljs-keyword">yield</span> prefixedValue
  }.runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__lists__"></a><a href="#__lists__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Lists</strong></h3>
<p>The following example uses the redis list api <code>RedisList</code> to insert elements into a redis list and reading them back
with limited size.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> monix.eval.<span class="hljs-type">Task</span>

<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-keyword">val</span> key1: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> key2: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> values: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]
<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)
<span class="hljs-keyword">val</span> prefix = <span class="hljs-string">"dummy-prefix-"</span>

<span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use { cmd =&gt;
    <span class="hljs-keyword">for</span> {
      initialSize &lt;- cmd.list.lPush(key1, values)
      <span class="hljs-comment">//copies all values from `key1` to `key2` adding a static prefix to each element </span>
      _ &lt;- cmd.list.lGetAll(key1)
        .mapEval(v =&gt; cmd.list.lPush(key2, prefix + v)).completedL
      <span class="hljs-comment">//checks if key1 and key2 have the same size</span>
      haveSameSize &lt;- cmd.list.lLen(key1).map(_ == initialSize)
    } <span class="hljs-keyword">yield</span> haveSameSize
  }.runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__server__"></a><a href="#__server__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Server</strong></h3>
<p>The following code shows how to remove all keys from all dbs in redis using the server api <code>RedisServer</code> a very basic
but also common use case:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> monix.eval.<span class="hljs-type">Task</span>

<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)
<span class="hljs-keyword">val</span> prefix = <span class="hljs-string">"dummy-prefix-"</span>

<span class="hljs-keyword">val</span> f = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf.use(_.server.flushAll).runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__sets__"></a><a href="#__sets__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Sets</strong></h3>
<p>The <a href="https://redis.io/commands#set">Redis Set commands api</a> provides operations to work with <em>sets</em>,
see a practical example in below code snippet.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> monix.eval.<span class="hljs-type">Task</span>
<span class="hljs-keyword">val</span> k1: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> k2: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://localhost:6379"</span>)

<span class="hljs-keyword">val</span> f = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use { cmd =&gt;
    <span class="hljs-keyword">for</span> {
      _ &lt;- cmd.set.sAdd(k1, <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>) *&gt;
        cmd.set.sAdd(k2, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>) 
      finalSize &lt;- cmd.set.sUnionStore(k1, k2)
    } <span class="hljs-keyword">yield</span> finalSize <span class="hljs-comment">//4 = ["a", "b", "c", "d"]</span>
  }.runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__sortedsets__"></a><a href="#__sortedsets__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>SortedSets</strong></h3>
<p>The <a href="https://redis.io/commands#sorted_set">Redis SortedSet commands api</a> provides operations to work with <em>sorted sets</em>,
see a practical example in below code snippet, where three scored elements (akka <code>VScore</code>), are inserted into a sorted set and
then incrementing the score of the middle one.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}
<span class="hljs-keyword">import</span> monix.connect.redis.domain.{<span class="hljs-type">VScore</span>, <span class="hljs-type">ZRange</span>}

<span class="hljs-keyword">val</span> k: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> redisUri: <span class="hljs-type">RedisUri</span>

<span class="hljs-keyword">val</span> f = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use { cmd =&gt;
    <span class="hljs-keyword">for</span> {
      _ &lt;- cmd.sortedSet.zAdd(k, <span class="hljs-type">VScore</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">1</span>)) &gt;&gt; 
        cmd.sortedSet.zAdd(k, <span class="hljs-type">VScore</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">2</span>)) &gt;&gt; 
        cmd.sortedSet.zAdd(k, <span class="hljs-type">VScore</span>(<span class="hljs-string">"Jamie"</span>, <span class="hljs-number">5</span>))
      <span class="hljs-comment">//increments middle one by `increment` so it becomes the highest score of the set</span>
      _ &lt;- cmd.sortedSet.zIncrBy(k, <span class="hljs-number">6</span>, <span class="hljs-string">"Bob"</span>) 
      <span class="hljs-comment">//returns those members with score higher than 4 ["Bob", "Jamie"]</span>
      zRange &lt;- cmd.sortedSet.zRangeByScore(k, <span class="hljs-type">ZRange</span>.gt(<span class="hljs-number">5</span>)).toListL
      min &lt;- cmd.sortedSet.zPopMin(k) <span class="hljs-comment">// Alice</span>
      max &lt;- cmd.sortedSet.zPopMax(k) <span class="hljs-comment">// Bob</span>
    } <span class="hljs-keyword">yield</span> (min, max, zRange)
  }.runToFuture
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="__strings__"></a><a href="#__strings__" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>Strings</strong></h3>
<p>The <a href="https://redis.io/commands#string">Redis Strings commands api</a> provides operations to work with <em>strings</em>,
see a practical example in below code snippet, where we insert a string into the given key and get its size.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisCmd</span>, <span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}

<span class="hljs-keyword">val</span> k: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> v: <span class="hljs-type">String</span>
<span class="hljs-keyword">val</span> redisUri: <span class="hljs-type">RedisUri</span>

<span class="hljs-keyword">val</span> f = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
  .connectUtf
  .use { cmd =&gt;
    <span class="hljs-keyword">for</span> {
      _ &lt;- cmd.string.set(k, v)
      size &lt;- cmd.string.strLen(k)
    } <span class="hljs-keyword">yield</span> size
  }.runToFuture
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="local-testing"></a><a href="#local-testing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local testing</h2>
<p>The local tests will use the <a href="https://hub.docker.com/_/redis/">redis docker image</a> from <em>docker hub</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="standalone-server"></a><a href="#standalone-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standalone server</h3>
<p>Add the following service description to your <code>docker-compose.yml</code> file:</p>
<pre><code class="hljs css language-yaml"> <span class="hljs-attr">redis:</span>
   <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span>
   <span class="hljs-attr">ports:</span>
     <span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span>
</code></pre>
<p>Run the following command to build and start the redis server:</p>
<pre><code class="hljs css language-shell script">docker-compose -f ./docker-compose.yml up -d redis
</code></pre>
<p>Check out that the service has started correctly.</p>
<p>Finally, following code shows how you can create the redis connection to the local server, but you would have to modify
that to fit your use case - i.e it will be different to connect to a redis cluster or if authenticating to the server is
needed using with key and secret, etc.)</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client
<span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}

<span class="hljs-keyword">val</span> redisUri = <span class="hljs-type">RedisUri</span>(<span class="hljs-string">"redis://host:port"</span>)
<span class="hljs-keyword">val</span> standaloneConn = <span class="hljs-type">RedisConnection</span>.standalone(redisUri)
</code></pre>
<p>Now you are ready to run your application!</p>
<h3><a class="anchor" aria-hidden="true" id="cluster-1"></a><a href="#cluster-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cluster</h3>
<p>On the other hand, if you want to test how your application will behave running with a redis cluster, you can use <a href="https://hub.docker.com/r/grokzen/redis-cluster/">grokzen/redis-cluster</a></p>
<pre><code class="hljs css language-yaml">  <span class="hljs-attr">redisCluster:</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">grokzen/redis-cluster:6.0.5</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7000:7000"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7001:7001"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7002:7002"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7003:7003"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7004:7004"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"7005:7005"</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STANDALONE=true</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">IP=0.0.0.0</span>
</code></pre>
<p>And then from the application side you would do:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.connect.redis.client
<span class="hljs-keyword">import</span> monix.connect.redis.client.{<span class="hljs-type">RedisConnection</span>, <span class="hljs-type">RedisUri</span>}

<span class="hljs-keyword">val</span> redisUris: <span class="hljs-type">Seq</span>[<span class="hljs-type">RedisUri</span>] = (<span class="hljs-number">0</span> to <span class="hljs-number">5</span>).map(n =&gt; <span class="hljs-type">RedisUri</span>(<span class="hljs-string">s"redis://localhost:<span class="hljs-subst">${(7000 + n)}</span>"</span>))
<span class="hljs-keyword">val</span> clusterConn = <span class="hljs-type">RedisConnection</span>.cluster(redisUris)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="yet-to-come"></a><a href="#yet-to-come" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Yet to come</h2>
<ul>
<li><em>Master Replica</em> connection.</li>
<li><em>Pub/sub</em>, <em>Streams</em>, <em>Transactions</em>, <em>HyperLogLog</em>, <em>Geolocation</em>, <em>Scripting</em> commands.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/mongodb"><span class="arrow-prev">← </span><span class="function-name-prevnext">MongoDB</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a></li><li><a href="#dependency">Dependency</a></li><li><a href="#redis-connection">Redis Connection</a><ul class="toc-headings"><li><a href="#standalone">Standalone</a></li><li><a href="#cluster">Cluster</a></li></ul></li><li><a href="#rediscmd">RedisCmd</a></li><li><a href="#custom-codecs">Custom Codecs</a><ul class="toc-headings"><li><a href="#utfcodec">UTFCodec</a></li><li><a href="#bytescodec">BytesCodec</a></li></ul></li><li><a href="#commands">Commands</a><ul class="toc-headings"><li><a href="#__keys__"><strong>Keys</strong></a></li><li><a href="#__hashes__"><strong>Hashes</strong></a></li><li><a href="#__lists__"><strong>Lists</strong></a></li><li><a href="#__server__"><strong>Server</strong></a></li><li><a href="#__sets__"><strong>Sets</strong></a></li><li><a href="#__sortedsets__"><strong>SortedSets</strong></a></li><li><a href="#__strings__"><strong>Strings</strong></a></li></ul></li><li><a href="#local-testing">Local testing</a><ul class="toc-headings"><li><a href="#standalone-server">Standalone server</a></li><li><a href="#cluster-1">Cluster</a></li></ul></li><li><a href="#yet-to-come">Yet to come</a></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright © 2020-2022 The Monix Connect Developers.</section></footer></div></body></html>